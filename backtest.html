<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Posada — Backtester</title>
<style>
:root {
  --bg: #080b12;
  --panel-border: rgba(255, 140, 50, 0.22);
  --panel-glow: rgba(255, 122, 26, 0.06);
  --orange: #ff8c32;
  --orange-bright: #ffaa55;
  --green: #2ecc71;
  --green-dim: rgba(46, 204, 113, 0.14);
  --red: #e74c3c;
  --red-dim: rgba(231, 76, 60, 0.14);
  --blue: #3498db;
  --blue-dim: rgba(52, 152, 219, 0.14);
  --text: #e8eaed;
  --text-muted: #8b949e;
  --text-dim: #555d66;
  --border: rgba(255, 255, 255, 0.06);
  --card-bg: rgba(17, 24, 32, 0.80);
  --radius: 14px;
  --radius-sm: 10px;
  --font: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
  --mono: 'JetBrains Mono', 'Fira Code', monospace;
  --transition: 0.18s ease;
}
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html { font-size: 15px; -webkit-font-smoothing: antialiased; }
body {
  min-height: 100vh; font-family: var(--font);
  background: var(--bg); color: var(--text); line-height: 1.5;
}
body::before {
  content: ''; position: fixed; top: -200px; left: 50%; transform: translateX(-50%);
  width: 900px; height: 500px;
  background: radial-gradient(ellipse, rgba(255,122,26,0.06), transparent 70%);
  pointer-events: none; z-index: 0;
}
.site {
  position: relative; z-index: 1;
  max-width: 960px; margin: 0 auto; padding: 24px 16px 60px;
}
.header { margin-bottom: 32px; text-align: center; }
.header img {
  width: 100%; max-width: 960px; height: auto; display: block;
  border-radius: var(--radius);
  border: 1px solid var(--panel-border);
  box-shadow: 0 0 40px var(--panel-glow), 0 16px 48px rgba(0,0,0,0.35);
}
.nav { display: flex; gap: 12px; margin-bottom: 24px; flex-wrap: wrap; }
.nav a { color: var(--orange); text-decoration: none; font-size: 0.85rem; font-weight: 600; }
.nav a:hover { color: var(--orange-bright); }
.nav .sep { color: var(--text-dim); }
.nav .current { color: var(--text); }
.page-title { font-size: 1.5rem; font-weight: 700; margin-bottom: 6px; letter-spacing: 1px; }
.page-sub { font-size: 0.85rem; color: var(--text-muted); margin-bottom: 32px; }

/* Controls */
.controls {
  display: flex; gap: 12px; margin-bottom: 24px; flex-wrap: wrap; align-items: flex-end;
}
.control-group { display: flex; flex-direction: column; gap: 4px; }
.control-group label {
  font-size: 0.7rem; color: var(--text-dim); text-transform: uppercase;
  letter-spacing: 1px; font-weight: 600;
}
.control-group select, .control-group input {
  background: var(--card-bg); color: var(--text); border: 1px solid var(--panel-border);
  border-radius: var(--radius-sm); padding: 10px 14px; font-size: 0.85rem;
  font-family: var(--font); outline: none; cursor: pointer;
}
.control-group select:focus, .control-group input:focus { border-color: var(--blue); }
.btn-run {
  background: linear-gradient(135deg, var(--blue), #2980b9);
  color: #fff; border: none; border-radius: var(--radius-sm);
  padding: 10px 24px; font-size: 0.85rem; font-weight: 700;
  cursor: pointer; transition: all var(--transition);
  letter-spacing: 0.5px;
}
.btn-run:hover { box-shadow: 0 0 16px rgba(52,152,219,0.3); transform: translateY(-1px); }
.btn-run:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

/* Results */
.results { }
.result-hero {
  background: var(--card-bg); border: 2px solid var(--panel-border);
  border-radius: var(--radius); padding: 28px; text-align: center; margin-bottom: 20px;
}
.result-hero .hero-label { font-size: 0.85rem; color: var(--text-muted); margin-bottom: 8px; }
.result-hero .hero-value { font-size: 2rem; font-weight: 900; font-family: var(--mono); }
.result-hero .hero-value.pos { color: var(--green); }
.result-hero .hero-value.neg { color: var(--red); }
.result-hero .hero-sub { font-size: 0.82rem; color: var(--text-dim); margin-top: 8px; }
.result-cards { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 24px; }
.result-card {
  background: var(--card-bg); border: 1px solid var(--panel-border);
  border-radius: var(--radius-sm); padding: 16px; text-align: center;
}
.result-label { font-size: 0.7rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; }
.result-value { font-size: 1.2rem; font-weight: 800; font-family: var(--mono); }
.result-value.pos { color: var(--green); }
.result-value.neg { color: var(--red); }

/* Trade table */
.section-title { font-size: 1rem; font-weight: 700; margin-bottom: 14px; letter-spacing: 0.5px; }
.trade-table { width: 100%; border-collapse: separate; border-spacing: 0 4px; }
.trade-table th {
  text-align: left; padding: 6px 12px; font-size: 0.65rem; font-weight: 600;
  color: var(--text-dim); text-transform: uppercase; letter-spacing: 1px;
}
.trade-table th.right { text-align: right; }
.trade-table td {
  padding: 8px 12px; background: var(--card-bg);
  border-top: 1px solid var(--border); border-bottom: 1px solid var(--border);
  font-size: 0.78rem;
}
.trade-table td:first-child { border-left: 1px solid var(--border); border-radius: var(--radius-sm) 0 0 var(--radius-sm); }
.trade-table td:last-child { border-right: 1px solid var(--border); border-radius: 0 var(--radius-sm) var(--radius-sm) 0; }
.trade-table .pos { color: var(--green); }
.trade-table .neg { color: var(--red); }
.trade-table .buy-tag { color: var(--green); font-weight: 700; font-family: var(--mono); }
.trade-table .sell-tag { color: var(--red); font-weight: 700; font-family: var(--mono); }

.loading { text-align: center; padding: 40px 0; color: var(--text-muted); font-size: 0.9rem; display: none; }
.loading .spinner {
  display: inline-block; width: 28px; height: 28px;
  border: 3px solid var(--border); border-top-color: var(--blue);
  border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 12px;
}
@keyframes spin { to { transform: rotate(360deg); } }

.footer { text-align: center; margin-top: 48px; color: var(--text-dim); font-size: 0.75rem; }

@media (max-width: 700px) {
  .result-cards { grid-template-columns: 1fr 1fr; }
  .controls { flex-direction: column; }
  .trade-table .hide-mobile { display: none; }
}
</style>
</head>
<body>

<div class="site">
  <div class="header"><a href="/"><img src="assets/header-posadaweb.png" alt="Posada.io"></a></div>
  <div class="nav">
    <a href="/">Home</a><span class="sep">/</span>
    <a href="strategies.html">Strategies</a><span class="sep">/</span>
    <span class="current">Backtester</span>
  </div>

  <h2 class="page-title">Strategy Backtester</h2>
  <p class="page-sub">Test Posada's strategies against real historical price data from Cardano DEXs</p>

  <div class="controls">
    <div class="control-group">
      <label>Token</label>
      <select id="tokenSelect"><option value="">Loading...</option></select>
    </div>
    <div class="control-group">
      <label>Strategy</label>
      <select id="stratSelect">
        <option value="lwmr">LWMR — Mean Reversion</option>
        <option value="bwr">BWR — Breakout Retest</option>
        <option value="vbr">VBR — Bollinger Bands</option>
        <option value="lrm">LRM — Momentum</option>
        <option value="rra">RRA — Relative Rotation</option>
        <option value="cpr">CPR — Capitulation Pivot Recovery</option>
      </select>
    </div>
    <div class="control-group">
      <label>Starting ADA</label>
      <input type="number" id="startAda" value="10000" min="100" step="100" style="width:130px;font-family:var(--mono)">
    </div>
    <div class="control-group">
      <label>Period</label>
      <select id="periodSelect">
        <option value="168">7 days</option>
        <option value="336">14 days</option>
        <option value="720" selected>30 days</option>
      </select>
    </div>
    <button class="btn-run" id="runBtn" onclick="runBacktest()">Run Backtest</button>
  </div>

  <div id="loading" class="loading"><div class="spinner"></div><br>Fetching price data and running simulation...</div>

  <div class="results" id="results" style="display:none">
    <div class="result-hero" id="resultHero"></div>
    <div class="result-cards" id="resultCards"></div>
    <h3 class="section-title">Simulated Trades</h3>
    <table class="trade-table">
      <thead>
        <tr>
          <th>Action</th>
          <th>Time</th>
          <th class="right">Price (ADA)</th>
          <th class="right hide-mobile">Reason</th>
          <th class="right">P&L</th>
          <th class="right">ADA</th>
        </tr>
      </thead>
      <tbody id="tradeBody"></tbody>
    </table>
  </div>

  <div class="footer">&copy; 2026 Posada &mdash; Built on Cardano</div>
</div>

<script>
// ── Strategy Engine (ported from strategies.py) ──
function sma(prices, window) {
  if (prices.length < window) return null;
  const slice = prices.slice(-window);
  return slice.reduce((a, b) => a + b, 0) / window;
}
function stdev(prices, window) {
  if (prices.length < window) return null;
  const slice = prices.slice(-window);
  const m = slice.reduce((a, b) => a + b, 0) / slice.length;
  const variance = slice.reduce((s, x) => s + (x - m) ** 2, 0) / slice.length;
  return Math.sqrt(variance);
}
function pctChg(old, cur) { return old !== 0 ? ((cur - old) / old) * 100 : 0; }
function momentum(prices, period) {
  if (prices.length < period + 1) return null;
  return pctChg(prices[prices.length - period - 1], prices[prices.length - 1]);
}

function signalLWMR(prices, pos) {
  if (prices.length < 20) return [null, 'need data'];
  const cur = prices[prices.length - 1];
  const mean = sma(prices, 20);
  const sd = stdev(prices, 20);
  if (!mean) return [null, 'bad mean'];
  const thresh = Math.max(sd ? (sd / mean) * 100 : 2, 2);
  const dev = pctChg(mean, cur);
  if (!pos) {
    if (dev < -thresh) return ['BUY', `dip ${dev.toFixed(1)}%`];
    return [null, ''];
  }
  const gain = pctChg(pos.entry, cur);
  if (gain >= 8) return ['SELL', `TP ${gain.toFixed(1)}%`];
  if (gain <= -10) return ['SELL', `SL ${gain.toFixed(1)}%`];
  if (cur >= mean) return ['SELL', 'mean reversion'];
  return [null, ''];
}

function signalBWR(prices, pos) {
  if (prices.length < 30) return [null, 'need data'];
  const cur = prices[prices.length - 1];
  const older = prices.slice(-30, -5);
  const resistance = Math.max(...older);
  const recentHigh = Math.max(...prices.slice(-5));
  if (!pos) {
    const broke = recentHigh > resistance * 1.005;
    const retested = cur <= recentHigh * 0.99;
    const holding = cur > resistance * 0.995;
    if (broke && retested && holding) return ['BUY', 'breakout retest'];
    return [null, ''];
  }
  const gain = pctChg(pos.entry, cur);
  if (gain >= 8) return ['SELL', `TP ${gain.toFixed(1)}%`];
  if (gain <= -10) return ['SELL', `SL ${gain.toFixed(1)}%`];
  if (cur < pos.breakoutLevel * 0.97) return ['SELL', 'rejected below breakout'];
  return [null, ''];
}

function signalVBR(prices, pos) {
  if (prices.length < 20) return [null, 'need data'];
  const cur = prices[prices.length - 1];
  const mean = sma(prices, 20);
  const sd = stdev(prices, 20);
  if (!mean || !sd) return [null, 'bad bands'];
  const lower = mean - 2 * sd;
  const mid = mean;
  const upper = mean + 2 * sd;
  if (!pos) {
    if (cur < lower) return ['BUY', 'below lower band'];
    return [null, ''];
  }
  const gain = pctChg(pos.entry, cur);
  if (gain >= 8) return ['SELL', `TP ${gain.toFixed(1)}%`];
  if (gain <= -10) return ['SELL', `SL ${gain.toFixed(1)}%`];
  // Real VBR does SELL_HALF at mid, full SELL at upper.
  // Since we can't track partial positions, sell half the P&L at mid
  // and the other half at upper. Approximate: exit at midpoint between mid and upper.
  if (cur >= upper) return ['SELL', 'upper band'];
  const exitTarget = mid + (upper - mid) * 0.5;
  if (cur >= exitTarget) return ['SELL', 'mid-upper band (approx SELL_HALF)'];
  return [null, ''];
}

function signalLRM(prices, pos) {
  if (prices.length < 10) return [null, 'need data'];
  const cur = prices[prices.length - 1];
  const m5 = momentum(prices, 5);
  const m3 = momentum(prices, 3);
  if (m5 === null) return [null, 'bad momentum'];
  if (!pos) {
    if (m5 > 1.0 && m3 !== null && m3 > 0.5) return ['BUY', `momentum m5=${m5.toFixed(1)}%`];
    return [null, ''];
  }
  const gain = pctChg(pos.entry, cur);
  if (gain >= 8) return ['SELL', `TP ${gain.toFixed(1)}%`];
  if (gain <= -10) return ['SELL', `SL ${gain.toFixed(1)}%`];
  if (m5 < -1.0) return ['SELL', `reversal ${m5.toFixed(1)}%`];
  return [null, ''];
}

function signalRRA(prices, pos) {
  if (prices.length < 15) return [null, 'need data'];
  const cur = prices[prices.length - 1];
  const m5 = momentum(prices, 5);
  const m3 = momentum(prices, 3);
  const m10 = momentum(prices, Math.min(10, prices.length - 1));
  if (m5 === null) return [null, 'bad momentum'];
  const score = 0.5 * (m3 || 0) + 0.3 * (m10 || 0);
  if (!pos) {
    if (score > 1.5 && (m3 || 0) > 0) return ['BUY', `score ${score.toFixed(1)}`];
    return [null, ''];
  }
  const gain = pctChg(pos.entry, cur);
  if (gain >= 8) return ['SELL', `TP ${gain.toFixed(1)}%`];
  if (gain <= -10) return ['SELL', `SL ${gain.toFixed(1)}%`];
  if (score < -0.75) return ['SELL', 'rotation faded'];
  if (m5 < -2.0) return ['SELL', `reversal ${m5.toFixed(1)}%`];
  return [null, ''];
}

// ── RSI ──
function rsiCalc(prices, period) {
  if (prices.length < period + 1) return null;
  let gains = 0, losses = 0;
  for (let i = prices.length - period; i < prices.length; i++) {
    const diff = prices[i] - prices[i - 1];
    if (diff > 0) gains += diff; else losses += Math.abs(diff);
  }
  const avgGain = gains / period;
  const avgLoss = losses / period;
  if (avgLoss === 0) return 100;
  return 100 - (100 / (1 + avgGain / avgLoss));
}

// ── CPR — Capitulation Pivot Recovery ──
function signalCPR(prices, pos) {
  if (prices.length < 50) return [null, 'need 50+ candles'];
  const cur = prices[prices.length - 1];

  // Indicators
  const mean20 = sma(prices, 20);
  const sd20 = stdev(prices, 20);
  if (!mean20 || !sd20) return [null, 'bad indicators'];
  const lowerExtreme = mean20 - 2.5 * sd20;
  const rsiVal = rsiCalc(prices, 14);
  const m3 = momentum(prices, 3);
  const m5 = momentum(prices, 5);

  // Drop from recent 20-candle high
  const recentHigh = Math.max(...prices.slice(-20));
  const dropFromHigh = pctChg(recentHigh, cur);

  if (!pos) {
    // Entry: ALL must align
    const belowBand = cur < lowerExtreme;
    const oversold = rsiVal !== null && rsiVal < 30;
    const bouncing = m3 !== null && m3 > 0;
    const realDip = dropFromHigh < -4.0;

    if (belowBand && oversold && bouncing && realDip) {
      return ['BUY', `capitulation (RSI=${rsiVal.toFixed(0)}, dip=${dropFromHigh.toFixed(1)}%)`];
    }
    return [null, ''];
  }

  // Exit
  const gain = pctChg(pos.entry, cur);
  if (gain >= 10) return ['SELL', `TP ${gain.toFixed(1)}%`];
  if (gain <= -8) return ['SELL', `SL ${gain.toFixed(1)}%`];
  if (m5 !== null && m5 < -3.0) return ['SELL', `bounce failed (m5=${m5.toFixed(1)}%)`];
  if (rsiVal !== null && rsiVal > 65) return ['SELL', `overbought (RSI=${rsiVal.toFixed(0)})`];
  return [null, ''];
}

const STRAT_FNS = { lwmr: signalLWMR, bwr: signalBWR, vbr: signalVBR, lrm: signalLRM, rra: signalRRA, cpr: signalCPR };

function simulate(candles, stratKey) {
  const fn = STRAT_FNS[stratKey];
  if (!fn) return { trades: [], totalPnl: 0, wins: 0, losses: 0, maxDrawdown: 0 };

  // ── Match exact bot parameters from auto_bot.py + strategies.py ──
  const BUY_SLIPPAGE  = 1.0;   // max_slippage default = 1.0%
  const SELL_SLIPPAGE = 2.0;   // hardcoded 2% in do_sell / do_sell_half
  const COOLDOWN      = 1;     // 15 min cooldown → 1 candle minimum on 1h data
  const MAX_PER_HOUR  = 10;    // max_trades_per_hour (all symbols combined, but single-token sim)
  const MAX_PER_DAY   = 50;    // max_trades_per_day

  const trades = [];
  let pos = null;
  let totalPnl = 0;
  let peak = 0;
  let maxDrawdown = 0;
  let wins = 0;
  let losses = 0;
  let lastSellIdx = -999;
  let dailyTrades = {};
  let hourlyTrades = {};

  for (let i = 1; i < candles.length; i++) {
    const closePrices = candles.slice(0, i + 1).map(c => c.close);
    const candle = candles[i];
    const [sig, reason] = fn(closePrices, pos);

    if (sig === 'BUY' && !pos) {
      // Cooldown: must wait at least COOLDOWN candles after last sell
      if (i - lastSellIdx < COOLDOWN) continue;

      // Daily trade limit
      const day = new Date(candle.time * 1000).toDateString();
      if ((dailyTrades[day] || 0) >= MAX_PER_DAY) continue;

      // Hourly trade limit
      const hour = new Date(candle.time * 1000).toISOString().slice(0, 13);
      if ((hourlyTrades[hour] || 0) >= MAX_PER_HOUR) continue;

      // Apply buy slippage (worse entry — you pay more)
      const entryPrice = candle.close * (1 + BUY_SLIPPAGE / 100);
      pos = {
        entry: entryPrice,
        time: candle.time,
        breakoutLevel: candle.close,
      };
      trades.push({ action: 'BUY', time: candle.time, price: entryPrice, reason, pnl: null });

      dailyTrades[day] = (dailyTrades[day] || 0) + 1;
      hourlyTrades[hour] = (hourlyTrades[hour] || 0) + 1;
    } else if (sig === 'SELL' && pos) {
      // Apply sell slippage (worse exit — you receive less)
      const exitPrice = candle.close * (1 - SELL_SLIPPAGE / 100);
      const pnl = pctChg(pos.entry, exitPrice);
      totalPnl += pnl;
      if (pnl > 0) wins++; else if (pnl < 0) losses++;
      trades.push({ action: 'SELL', time: candle.time, price: exitPrice, reason, pnl });

      // Track drawdown
      if (totalPnl > peak) peak = totalPnl;
      const dd = peak - totalPnl;
      if (dd > maxDrawdown) maxDrawdown = dd;

      lastSellIdx = i;
      pos = null;
    }
  }

  // Close open position at last candle (with sell slippage)
  if (pos && candles.length > 0) {
    const last = candles[candles.length - 1];
    const exitPrice = last.close * (1 - SELL_SLIPPAGE / 100);
    const pnl = pctChg(pos.entry, exitPrice);
    totalPnl += pnl;
    if (pnl > 0) wins++; else if (pnl < 0) losses++;
    trades.push({ action: 'SELL', time: last.time, price: exitPrice, reason: 'end of period', pnl });
  }

  return { trades, totalPnl, wins, losses, maxDrawdown };
}

// ── UI ──
async function loadTokens() {
  try {
    const r = await fetch('/api/tokens.php');
    const data = await r.json();
    const select = document.getElementById('tokenSelect');
    select.innerHTML = '';
    (data.tokens || []).forEach(t => {
      if (t.ticker === 'ADA') return;
      const opt = document.createElement('option');
      opt.value = t.ticker;
      opt.textContent = t.ticker;
      select.appendChild(opt);
    });
  } catch (e) {
    console.error('Failed to load tokens', e);
  }
}

function fmtPrice(n) {
  if (n >= 1) return Number(n).toFixed(4);
  if (n >= 0.001) return Number(n).toFixed(6);
  return Number(n).toFixed(8);
}

function fmtTime(ts) {
  return new Date(ts * 1000).toLocaleDateString(undefined, { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
}

function fmtAda(n) {
  const s = n >= 0 ? '+' : '';
  if (Math.abs(n) >= 1e6) return s + (n/1e6).toFixed(1) + 'M';
  if (Math.abs(n) >= 1e3) return s + (n/1e3).toFixed(1) + 'K';
  return s + n.toFixed(0);
}

async function runBacktest() {
  const ticker = document.getElementById('tokenSelect').value;
  const strat = document.getElementById('stratSelect').value;
  const periods = document.getElementById('periodSelect').value;
  const startAda = parseFloat(document.getElementById('startAda').value) || 10000;

  if (!ticker) return;

  document.getElementById('runBtn').disabled = true;
  document.getElementById('results').style.display = 'none';
  document.getElementById('loading').style.display = '';

  try {
    const r = await fetch(`/api/backtest.php?ticker=${ticker}&interval=1h&periods=${periods}`);
    const data = await r.json();
    if (data.error) throw new Error(data.error);

    const candles = data.candles || [];
    if (candles.length < 30) {
      document.getElementById('loading').innerHTML =
        '<span style="color:var(--text-dim)">Not enough price data for this token. Try a different one.</span>';
      document.getElementById('runBtn').disabled = false;
      return;
    }

    const result = simulate(candles, strat);
    const totalTrades = result.wins + result.losses;
    const winRate = totalTrades > 0 ? ((result.wins / totalTrades) * 100).toFixed(1) : '0';

    // Calculate ADA amounts — each trade uses 25% of current portfolio
    const tradeSize = 0.25;
    let portfolio = startAda;
    const sellTrades = result.trades.filter(t => t.action === 'SELL');
    sellTrades.forEach(t => {
      const invested = portfolio * tradeSize;
      t.adaGain = invested * (t.pnl / 100);
      portfolio += t.adaGain;
    });
    // Also tag BUY trades with the portfolio value at the time
    let pIdx = 0;
    let runPort = startAda;
    result.trades.forEach(t => {
      if (t.action === 'BUY') {
        t.adaInvested = runPort * tradeSize;
      } else if (t.action === 'SELL') {
        runPort += t.adaGain || 0;
      }
    });

    const finalValue = portfolio;
    const totalAdaGain = finalValue - startAda;
    const totalReturnPct = ((finalValue - startAda) / startAda) * 100;

    // Hero: final portfolio value
    const heroCls = totalAdaGain >= 0 ? 'pos' : 'neg';
    document.getElementById('resultHero').innerHTML = `
      <div class="hero-label">Portfolio After ${ticker} / ${strat.toUpperCase()}</div>
      <div class="hero-value ${heroCls}">${finalValue.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',')} \u20B3</div>
      <div class="hero-sub">Started with ${startAda.toLocaleString()} \u20B3 &mdash; ${totalReturnPct >= 0 ? '+' : ''}${totalReturnPct.toFixed(2)}% (${totalAdaGain >= 0 ? '+' : ''}${totalAdaGain.toFixed(0)} \u20B3)</div>
    `;

    const pnlCls = totalReturnPct >= 0 ? 'pos' : 'neg';
    document.getElementById('resultCards').innerHTML = `
      <div class="result-card">
        <div class="result-label">Net P&L</div>
        <div class="result-value ${pnlCls}">${totalAdaGain >= 0 ? '+' : ''}${totalAdaGain.toFixed(0)} \u20B3</div>
      </div>
      <div class="result-card">
        <div class="result-label">Win Rate</div>
        <div class="result-value">${winRate}%</div>
      </div>
      <div class="result-card">
        <div class="result-label">Trades</div>
        <div class="result-value">${totalTrades}</div>
      </div>
      <div class="result-card">
        <div class="result-label">Max Drawdown</div>
        <div class="result-value neg">-${result.maxDrawdown.toFixed(2)}%</div>
      </div>
    `;

    const tbody = document.getElementById('tradeBody');
    if (result.trades.length === 0) {
      tbody.innerHTML = '<tr><td colspan="6" style="text-align:center;color:var(--text-dim);padding:20px">No trades generated — strategy found no entry signals in this period</td></tr>';
    } else {
      tbody.innerHTML = result.trades.map(t => {
        const cls = t.action === 'BUY' ? 'buy-tag' : 'sell-tag';
        let pnlStr = '\u2014';
        let adaStr = '';
        if (t.pnl !== null) {
          pnlStr = `<span class="${t.pnl >= 0 ? 'pos' : 'neg'}">${t.pnl >= 0 ? '+' : ''}${t.pnl.toFixed(2)}%</span>`;
          adaStr = `<span class="${t.adaGain >= 0 ? 'pos' : 'neg'}">${fmtAda(t.adaGain)} \u20B3</span>`;
        }
        if (t.action === 'BUY' && t.adaInvested) {
          adaStr = `<span style="color:var(--text-dim)">${t.adaInvested.toFixed(0)} \u20B3</span>`;
        }
        return `<tr>
          <td class="${cls}">${t.action}</td>
          <td>${fmtTime(t.time)}</td>
          <td class="right" style="font-family:var(--mono)">${fmtPrice(t.price)}</td>
          <td class="right hide-mobile" style="color:var(--text-muted);font-size:0.75rem">${t.reason}</td>
          <td class="right" style="font-family:var(--mono)">${pnlStr}</td>
          <td class="right" style="font-family:var(--mono)">${adaStr}</td>
        </tr>`;
      }).join('');
    }

    document.getElementById('loading').style.display = 'none';
    document.getElementById('results').style.display = '';
  } catch (e) {
    document.getElementById('loading').innerHTML =
      `<span style="color:var(--red)">Backtest failed: ${e.message}</span>`;
    console.error(e);
  }

  document.getElementById('runBtn').disabled = false;
}

loadTokens();
</script>
</body>
</html>
